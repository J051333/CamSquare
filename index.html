---
layout: none
---

<head>
    <title>Unessay</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand&display=swap" rel="stylesheet">
</head>

<style>
    .bg {
        z-index: -1;
    }

    canvas#canv {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    /**:not(:empty) {*/
    /*    color: transparent;*/
    /*}*/

    #menu {
        position: absolute;
        top: 50%;
        left: 50%;
        height: 440px;
        width: 420px;
        color: black;
        z-index: 2;
        overflow: hidden;
        box-shadow: 0 0 25px 5px black;

        transform: translateX(-50%) translateY(-50%);
        border-radius: 1em;
    }

    #close {
        position: absolute;
        top: 0;
        right: 0;
        stroke: rgba(235, 75, 75, 1);
        transition-duration: 100ms;
    }

    #close:hover {
        stroke: rgba(170, 20, 20, 1);
    }

    #close:active {
        stroke: rgba(25, 0, 0, 0.75);
    }

    #menu-title {
        width: 100%;
        height: 10%;

        justify-content: center;
        text-align: center;
        vertical-align: middle;
    }

    #menu .options-container {
        position: relative;
        display: flex;
        flex-direction: column;
    }

    .float-option input {
        float: right;
        width: 45%
    }

    .float-option {
        margin: 10px 10px 10px 10px
    }

    .radio-option {
        display: grid;
        grid-template-columns: 1fr 3fr 1fr 3fr 1fr 3fr;
    }

    .radio-option label {
        padding-left: 0.25em;
    }

    .apply-btn {
        position: absolute;
        bottom: 0;
        height: 8%;
        width: 100%;
        background-color: rgba(17, 127, 79, 0.5);
        border: none;
        border-top: 2px outset rgba(12, 94, 59, 0.5);
        font-weight: bold;

        transition-duration: 0.2s;
    }

    .apply-btn:hover {
        background-color: rgba(17, 127, 79, 0.69);
        border-top: 2px outset rgba(12, 94, 59, 0.75);
    }

    .apply-btn:active {
        background-color: rgba(14, 110, 68, 0.8);
        border-top: 2px outset rgba(12, 94, 59, 1);
    }

    .full-bg-blur {
        position: absolute;
        background-color: #FFFFFF3F;
        backdrop-filter: blur(10px);
        height: 100%;
        width: 100%;
    }

    body {
        overflow: hidden;
        font-family: Quicksand, sans-serif;
    }
</style>

<div id="menu" hidden>
    <div class="full-bg-blur">
        <svg width="10%" height="10%" id="close">
            <circle cx="50%" cy="50%" r="30%"  stroke-width="10%" fill="none"/>
            <line x1="40%" y1="40%" x2="60%" y2="60%" stroke-width="10%" stroke-linecap="round"/>
            <line x1="40%" y1="60%" x2="60%" y2="40%" stroke-width="10%" stroke-linecap="round"/>
        </svg>

        <h1 id="menu-title">Options</h1>
        <form>
            <div class="options-container">
                <div class="float-option">
                    <label for="basecolor" id="basecolor-label">Base Color</label>
                    <input type="color" id="basecolor" name="basecolor" value="#3F51B0">
                </div>

                <div class="float-option">
                    <label for="bgcolor" id="bgcolor-label">Background Color</label>
                    <input type="color" id="bgcolor" name="bgcolor" value="#3F51B0">
                </div>

                <div class="radio-option">
                    <input type="radio" id="time" name="texttype" value="time" checked>
                    <label for="time" id="time-label">Time</label>
                    <input type="radio" id="text" name="texttype" value="text">
                    <label for="text" id="text-label">Text</label>
                    <input type="radio" id="notext" name="texttype" value="notext">
                    <label for="notext" id="notext-label">None</label>
                </div>

                <div id="display-text-box" class="float-option" hidden>
                    <label for="text-box" id="text-box-label">Text</label>
                    <input type="text" id="text-box" name="text-box">
                </div>

                <div id="display-text-color" class="float-option" hidden>
                    <label for="textcolor" id="textcolor-label">Text Color</label>
                    <input type="color" id="textcolor" name="textcolor" value="#3F51B0">
                </div>
            </div>
            <input type="submit" value="Apply" class="apply-btn"  id="apply">
        </form>
    </div>
</div>

<canvas id="canv"></canvas>
<video id="webcam" class="bg" autoplay></video>
<canvas id="vid-canvas" class="bg"></canvas>

<script>
    let textBox = document.getElementById("display-text-box");
    let textColor = document.getElementById("display-text-color");
    let textRadio = document.getElementById("text");

    document.querySelectorAll("input[type='radio']").forEach((r) => r.addEventListener("change", (e) => {
        if (textRadio === e.target) {
            textBox.hidden = false;
            textColor.hidden = false;
        } else {
            textBox.hidden = true;
            textColor.hidden = true;
        }
    }));
</script>

<script>
    let canvas;
    let cellScale = 6;
    let ctx;
    let video;
    let vidCanvas;
    let vidCtx;
    let cellCountX = 5 * cellScale;
    let cellCountY = 3 * cellScale;
    let timeScale = 0.3;
    let magCap = 2 / 60; // MUST BE A RATIO TO STAY SANE
    let maxColorOffset = 100; // both directions i.e. 50 results in Â±25
    let cameraAccess = false;
    let play = true;
    let baseInfluence = true;

    // Array of [position, step]
    const positions = [];
    const colors = [];

    function draw() {
        if (play) {
            colors[colors.length - 1] = averageImage();
        }
        ctx.fillStyle = colors[colors.length - 1];
        ctx.fillRect(0, 0, innerWidth * window.devicePixelRatio, innerHeight * window.devicePixelRatio);
        computePosition();
        tile();
    }

    function computePosition() {
        for (let i = 0; i < cellCountX; i++) {
            for (let j = 0; j < cellCountY; j++) {
                positions[i][j].pos += positions[i][j].timeStep;
                if (positions[i][j].pos >= 180) {
                    positions[i][j].pos = 0;
                }
            }
        }
    }

    async function tile() {
        if (!cameraAccess) return;
        const imageData = imageDataTo2dArray(capture());
        const cellWidth = Math.floor(canvas.width / cellCountX);
        const cellHeight = Math.floor(canvas.height / cellCountY);
        let offsetX = (canvas.width - cellCountX * cellWidth) / 2;
        let offsetY = (canvas.height - cellCountY * cellHeight) / 2;
        let widthOffset = cellWidth / 10;
        let heightOffset = cellHeight / 10;

        if (widthOffset < heightOffset) {
            ctx.lineWidth = widthOffset;
            heightOffset = 0
        } else {
            ctx.lineWidth = heightOffset;
            widthOffset = 0;
        }
        ctx.lineWidth = Math.min(cellWidth / 10, cellHeight / 10);

        let r, g, b;
        for (let i = 0; i < cellCountX; i++) {
            for (let j = 0; j < cellCountY; j++) {
                if (play) {
                    r = 0;
                    g = 0;
                    b = 0;

                    let vidCellWidth = Math.floor(vidCanvas.width / cellCountX);
                    let vidCellHeight = Math.floor(vidCanvas.height / cellCountY);
                    for (let x = 0; x < vidCellWidth; x++) {
                        for (let y = 0; y < vidCellHeight; y++) {
                            r += imageData[x + vidCellWidth * i][y + vidCellHeight * j].r;
                            g += imageData[x + vidCellWidth * i][y + vidCellHeight * j].g;
                            b += imageData[x + vidCellWidth * i][y + vidCellHeight * j].b;
                        }
                    }

                    r /= vidCellWidth * vidCellHeight;
                    g /= vidCellWidth * vidCellHeight;
                    b /= vidCellWidth * vidCellHeight;

                    ctx.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
                    colors[i][j] = ctx.fillStyle;
                } else {
                    ctx.fillStyle = colors[i][j];
                }

                let influence = magCap * Math.sin(positions[i][j].pos);
                ctx.fillRect(i * cellWidth + offsetX + cellWidth * (influence * baseInfluence), j * cellHeight + offsetY + cellHeight * (influence * baseInfluence), cellWidth - cellWidth * (influence * baseInfluence) * 2, cellHeight - cellHeight * (influence * baseInfluence) * 2);

                let spaceX = cellWidth * influence;
                let spaceY = cellHeight * influence;
                ctx.strokeStyle = "#00000025";

                if (cellWidth > cellHeight) {
                    spaceY += ctx.lineWidth / 2;
                } else {
                    spaceX += ctx.lineWidth / 2;
                }

                ctx.strokeRect(i * cellWidth + spaceX + offsetX + heightOffset / 2, j * cellHeight + spaceY + offsetY + widthOffset / 2, cellWidth - spaceX * 2 - heightOffset, cellHeight - spaceY * 2 - widthOffset);
                // ctx.strokeRect(i * cellWidth + spaceX / 2, j * cellHeight + spaceY / 2, cellWidth - spaceX, cellHeight - spaceY);
            }
        }
    }

    function imageDataTo2dArray(id) {
        const result = [];

        for (let i = 0; i < id.width; i++) {
            const column = [];
            for (let j = 0; j < id.height; j++) {
                let index = (j * id.width + i) * 4;
                let pixel = {
                    r: id.data[index],
                    g: id.data[index + 1],
                    b: id.data[index + 2],
                    a: 1,
                }

                column.push(pixel);
            }

            result.push(column);
        }

        return result;
    }

    function averageImage() {
        if (!cameraAccess) return;
        const imageData = capture();

        let r = 0n;
        let g = 0n;
        let b = 0n;

        for (let i = 0; i < imageData.data.length; i += 4) {
            r += BigInt(imageData.data[i]);
            g += BigInt(imageData.data[i + 1]);
            b += BigInt(imageData.data[i + 2]);
        }

        let pixelCount = imageData.data.length / 4;

        r /= BigInt(pixelCount);
        g /= BigInt(pixelCount);
        b /= BigInt(pixelCount);

        return `rgb(${r}, ${g}, ${b}, 1)`;
    }

    function initWebcam() {
        navigator.mediaDevices.getUserMedia({video: true}).then((mediaStream) => {
            video.srcObject = mediaStream;
            cameraAccess = true;
        }).catch((error) => {
            console.error("Couldn't access webcam: ", error);
            cameraAccess = false;
        });
    }

    function capture() {
        vidCanvas.width = video.videoWidth / 2;
        vidCanvas.height = video.videoHeight / 2;
        vidCtx.drawImage(video, 0, 0, vidCanvas.width, vidCanvas.height);
        return vidCtx.getImageData(0, 0, vidCanvas.width, vidCanvas.height);
    }

    function apply() {
        let textColor = document.getElementById("textcolor").value;
        let bgColor = document.getElementById("bgcolor").value;
        let baseColor = document.getElementById("basecolor").value;
        let text = document.getElementById("text-box").value;
        let selectedText = document.querySelector("input[name='texttype']:checked").value;

        if (true /* TODO: replace with the output of a tickbox for static background */) {
            play = false;
            colors[colors.length - 1] = bgColor;

            let r, g, b;
            for (let i = 0; i < colors.length; i++) {
                for (let j = 0; j < colors[i].length; j++) {
                    r = parseInt(baseColor.substring(1, 3), 16) + Math.random() * (maxColorOffset / 2) - maxColorOffset / 2;
                    g = parseInt(baseColor.substring(3, 5), 16) + Math.random() * (maxColorOffset / 2) - maxColorOffset / 2;
                    b = parseInt(baseColor.substring(5, 7), 16) + Math.random() * (maxColorOffset / 2) - maxColorOffset / 2;

                    r = clamp(0, 255, r);
                    g = clamp(0, 255, g);
                    b = clamp(0, 255, b);

                    colors[i][j] = `rgb(${r}, ${g}, ${b})`;
                }
            }
        }
    }

    function clamp(min, max, a) {
        return Math.min(Math.max(a, min), max);
    }

    document.addEventListener("DOMContentLoaded", function () {
        canvas = document.getElementById("canv");
        ctx = canvas.getContext("2d");

        window.addEventListener("resize", () => {
            if (window.devicePixelRatio >= 1) {
                canvas.height = window.innerHeight * window.devicePixelRatio;
                canvas.width = window.innerWidth * window.devicePixelRatio;
            } else {
                canvas.width = document.body.clientWidth;
                canvas.height = document.body.clientHeight;
            }

            positions.length = 0;
            colors.length = 0;
            for (let i = 0; i < cellCountX; i++) {
                positions.push([]);
                colors.push([]);
                for (let j = 0; j < cellCountY; j++) {
                    positions[i].push({
                        pos: Math.round(Math.random() * 360),
                        timeStep: Math.random() * timeScale, // TODO: Clamp to min
                    });
                    colors[i].push("#000000");
                }
            }
            colors.push("#000000"); // Background
        });

        document.addEventListener("keydown", function (e) {
            if (e.key === "Enter") {
                averageImage();
            }

            if (e.key === " ") {
                play = !play;
            }

            if (e.key === "Shift") {
                baseInfluence = !baseInfluence;
            }
        });

        canvas.addEventListener("click", () => {
            document.getElementById("menu").hidden = false;
        });

        document.getElementById("close").addEventListener("click", () => {
           document.getElementById("menu").hidden = true;
        });

        document.getElementById("apply").addEventListener("click", (e) => {
            e.preventDefault();
            apply();
            document.getElementById("menu").hidden = true;
        });

        video = document.getElementById("webcam");
        vidCanvas = document.getElementById("vid-canvas");
        vidCtx = vidCanvas.getContext("2d", {willReadFrequently: true});

        initWebcam();
        window.dispatchEvent(new Event("resize"));
        setInterval(draw, 100);
    });
</script>
